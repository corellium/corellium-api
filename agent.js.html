<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>agent.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Agent.html">Agent</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Agent.html#appList">appList</a></li><li data-type='method' style='display: none;'><a href="Agent.html#changeFileAttributes">changeFileAttributes</a></li><li data-type='method' style='display: none;'><a href="Agent.html#connectToWifi">connectToWifi</a></li><li data-type='method' style='display: none;'><a href="Agent.html#crashes">crashes</a></li><li data-type='method' style='display: none;'><a href="Agent.html#deleteFile">deleteFile</a></li><li data-type='method' style='display: none;'><a href="Agent.html#disableSSLPinning">disableSSLPinning</a></li><li data-type='method' style='display: none;'><a href="Agent.html#disableUIAutomation">disableUIAutomation</a></li><li data-type='method' style='display: none;'><a href="Agent.html#disconnect">disconnect</a></li><li data-type='method' style='display: none;'><a href="Agent.html#disconnectFromWifi">disconnectFromWifi</a></li><li data-type='method' style='display: none;'><a href="Agent.html#download">download</a></li><li data-type='method' style='display: none;'><a href="Agent.html#enableSSLPinning">enableSSLPinning</a></li><li data-type='method' style='display: none;'><a href="Agent.html#enableUIAutomation">enableUIAutomation</a></li><li data-type='method' style='display: none;'><a href="Agent.html#getProfile">getProfile</a></li><li data-type='method' style='display: none;'><a href="Agent.html#getProp">getProp</a></li><li data-type='method' style='display: none;'><a href="Agent.html#install">install</a></li><li data-type='method' style='display: none;'><a href="Agent.html#installFile">installFile</a></li><li data-type='method' style='display: none;'><a href="Agent.html#installProfile">installProfile</a></li><li data-type='method' style='display: none;'><a href="Agent.html#installProvisioningProfile">installProvisioningProfile</a></li><li data-type='method' style='display: none;'><a href="Agent.html#isSSLPinningEnabled">isSSLPinningEnabled</a></li><li data-type='method' style='display: none;'><a href="Agent.html#kill">kill</a></li><li data-type='method' style='display: none;'><a href="Agent.html#listProvisioningProfiles">listProvisioningProfiles</a></li><li data-type='method' style='display: none;'><a href="Agent.html#lockDevice">lockDevice</a></li><li data-type='method' style='display: none;'><a href="Agent.html#preApproveProvisioningProfile">preApproveProvisioningProfile</a></li><li data-type='method' style='display: none;'><a href="Agent.html#profileList">profileList</a></li><li data-type='method' style='display: none;'><a href="Agent.html#ready">ready</a></li><li data-type='method' style='display: none;'><a href="Agent.html#removeProfile">removeProfile</a></li><li data-type='method' style='display: none;'><a href="Agent.html#removeProvisioningProfile">removeProvisioningProfile</a></li><li data-type='method' style='display: none;'><a href="Agent.html#run">run</a></li><li data-type='method' style='display: none;'><a href="Agent.html#runActivity">runActivity</a></li><li data-type='method' style='display: none;'><a href="Agent.html#runFrida">runFrida</a></li><li data-type='method' style='display: none;'><a href="Agent.html#runFridaKill">runFridaKill</a></li><li data-type='method' style='display: none;'><a href="Agent.html#runFridaPs">runFridaPs</a></li><li data-type='method' style='display: none;'><a href="Agent.html#shellExec">shellExec</a></li><li data-type='method' style='display: none;'><a href="Agent.html#shutdown">shutdown</a></li><li data-type='method' style='display: none;'><a href="Agent.html#stat">stat</a></li><li data-type='method' style='display: none;'><a href="Agent.html#tempFile">tempFile</a></li><li data-type='method' style='display: none;'><a href="Agent.html#uninstall">uninstall</a></li><li data-type='method' style='display: none;'><a href="Agent.html#unlockDevice">unlockDevice</a></li><li data-type='method' style='display: none;'><a href="Agent.html#upload">upload</a></li></ul></li><li><a href="Corellium.html">Corellium</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Corellium.html#addProjectKey">addProjectKey</a></li><li data-type='method' style='display: none;'><a href="Corellium.html#createProject">createProject</a></li><li data-type='method' style='display: none;'><a href="Corellium.html#createRole">createRole</a></li><li data-type='method' style='display: none;'><a href="Corellium.html#createUser">createUser</a></li><li data-type='method' style='display: none;'><a href="Corellium.html#deleteProjectKey">deleteProjectKey</a></li><li data-type='method' style='display: none;'><a href="Corellium.html#destroyRole">destroyRole</a></li><li data-type='method' style='display: none;'><a href="Corellium.html#destroyUser">destroyUser</a></li><li data-type='method' style='display: none;'><a href="Corellium.html#files">files</a></li><li data-type='method' style='display: none;'><a href="Corellium.html#generateApiToken">generateApiToken</a></li><li data-type='method' style='display: none;'><a href="Corellium.html#getProject">getProject</a></li><li data-type='method' style='display: none;'><a href="Corellium.html#getTeam">getTeam</a></li><li data-type='method' style='display: none;'><a href="Corellium.html#getTeamsAndUsers">getTeamsAndUsers</a></li><li data-type='method' style='display: none;'><a href="Corellium.html#getToken">getToken</a></li><li data-type='method' style='display: none;'><a href="Corellium.html#getUser">getUser</a></li><li data-type='method' style='display: none;'><a href="Corellium.html#login">login</a></li><li data-type='method' style='display: none;'><a href="Corellium.html#projectKeys">projectKeys</a></li><li data-type='method' style='display: none;'><a href="Corellium.html#projectNamed">projectNamed</a></li><li data-type='method' style='display: none;'><a href="Corellium.html#projects">projects</a></li><li data-type='method' style='display: none;'><a href="Corellium.html#removeApiToken">removeApiToken</a></li><li data-type='method' style='display: none;'><a href="Corellium.html#roles">roles</a></li><li data-type='method' style='display: none;'><a href="Corellium.html#supported">supported</a></li><li data-type='method' style='display: none;'><a href="Corellium.html#teams">teams</a></li><li data-type='method' style='display: none;'><a href="Corellium.html#users">users</a></li></ul></li><li><a href="Input.html">Input</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Input.html#delay">delay</a></li><li data-type='method' style='display: none;'><a href="Input.html#press">press</a></li><li data-type='method' style='display: none;'><a href="Input.html#pressRelease">pressRelease</a></li><li data-type='method' style='display: none;'><a href="Input.html#release">release</a></li><li data-type='method' style='display: none;'><a href="Input.html#swipeTo">swipeTo</a></li><li data-type='method' style='display: none;'><a href="Input.html#tap">tap</a></li><li data-type='method' style='display: none;'><a href="Input.html#touch">touch</a></li><li data-type='method' style='display: none;'><a href="Input.html#touchUp">touchUp</a></li></ul></li><li><a href="Instance.html">Instance</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Instance.html#_waitFor">_waitFor</a></li><li data-type='method' style='display: none;'><a href="Instance.html#agent">agent</a></li><li data-type='method' style='display: none;'><a href="Instance.html#clearCoreTraceFilter">clearCoreTraceFilter</a></li><li data-type='method' style='display: none;'><a href="Instance.html#clearCoreTraceLog">clearCoreTraceLog</a></li><li data-type='method' style='display: none;'><a href="Instance.html#clearPanics">clearPanics</a></li><li data-type='method' style='display: none;'><a href="Instance.html#compressAndUploadImage">compressAndUploadImage</a></li><li data-type='method' style='display: none;'><a href="Instance.html#console">console</a></li><li data-type='method' style='display: none;'><a href="Instance.html#consoleLog">consoleLog</a></li><li data-type='method' style='display: none;'><a href="Instance.html#deleteImage">deleteImage</a></li><li data-type='method' style='display: none;'><a href="Instance.html#deleteIotFirmware">deleteIotFirmware</a></li><li data-type='method' style='display: none;'><a href="Instance.html#deleteKernel">deleteKernel</a></li><li data-type='method' style='display: none;'><a href="Instance.html#destroy">destroy</a></li><li data-type='method' style='display: none;'><a href="Instance.html#disableExposedPort">disableExposedPort</a></li><li data-type='method' style='display: none;'><a href="Instance.html#downloadCoreTraceLog">downloadCoreTraceLog</a></li><li data-type='method' style='display: none;'><a href="Instance.html#downloadPcap">downloadPcap</a></li><li data-type='method' style='display: none;'><a href="Instance.html#enableExposedPort">enableExposedPort</a></li><li data-type='method' style='display: none;'><a href="Instance.html#executeFridaScript">executeFridaScript</a></li><li data-type='method' style='display: none;'><a href="Instance.html#finishRestore">finishRestore</a></li><li data-type='method' style='display: none;'><a href="Instance.html#finishUpgrade">finishUpgrade</a></li><li data-type='method' style='display: none;'><a href="Instance.html#fridaConsole">fridaConsole</a></li><li data-type='method' style='display: none;'><a href="Instance.html#getCoreTraceThreadList">getCoreTraceThreadList</a></li><li data-type='method' style='display: none;'><a href="Instance.html#getImages">getImages</a></li><li data-type='method' style='display: none;'><a href="Instance.html#getPeripherals">getPeripherals</a></li><li data-type='method' style='display: none;'><a href="Instance.html#message">message</a></li><li data-type='method' style='display: none;'><a href="Instance.html#messageRaw">messageRaw</a></li><li data-type='method' style='display: none;'><a href="Instance.html#modifyBootOptions">modifyBootOptions</a></li><li data-type='method' style='display: none;'><a href="Instance.html#modifyPeripherals">modifyPeripherals</a></li><li data-type='method' style='display: none;'><a href="Instance.html#netdump">netdump</a></li><li data-type='method' style='display: none;'><a href="Instance.html#networkMonitor">networkMonitor</a></li><li data-type='method' style='display: none;'><a href="Instance.html#newAgent">newAgent</a></li><li data-type='method' style='display: none;'><a href="Instance.html#newNetdump">newNetdump</a></li><li data-type='method' style='display: none;'><a href="Instance.html#newNetworkMonitor">newNetworkMonitor</a></li><li data-type='method' style='display: none;'><a href="Instance.html#panics">panics</a></li><li data-type='method' style='display: none;'><a href="Instance.html#pause">pause</a></li><li data-type='method' style='display: none;'><a href="Instance.html#rate">rate</a></li><li data-type='method' style='display: none;'><a href="Instance.html#reboot">reboot</a></li><li data-type='method' style='display: none;'><a href="Instance.html#rename">rename</a></li><li data-type='method' style='display: none;'><a href="Instance.html#restoreBackup">restoreBackup</a></li><li data-type='method' style='display: none;'><a href="Instance.html#sendInput">sendInput</a></li><li data-type='method' style='display: none;'><a href="Instance.html#setCoreTraceFilter">setCoreTraceFilter</a></li><li data-type='method' style='display: none;'><a href="Instance.html#snapshots">snapshots</a></li><li data-type='method' style='display: none;'><a href="Instance.html#start">start</a></li><li data-type='method' style='display: none;'><a href="Instance.html#startCoreTrace">startCoreTrace</a></li><li data-type='method' style='display: none;'><a href="Instance.html#stop">stop</a></li><li data-type='method' style='display: none;'><a href="Instance.html#stopCoreTrace">stopCoreTrace</a></li><li data-type='method' style='display: none;'><a href="Instance.html#takeScreenshot">takeScreenshot</a></li><li data-type='method' style='display: none;'><a href="Instance.html#takeSnapshot">takeSnapshot</a></li><li data-type='method' style='display: none;'><a href="Instance.html#unpause">unpause</a></li><li data-type='method' style='display: none;'><a href="Instance.html#upgrade">upgrade</a></li><li data-type='method' style='display: none;'><a href="Instance.html#uploadDeviceTree">uploadDeviceTree</a></li><li data-type='method' style='display: none;'><a href="Instance.html#uploadImage">uploadImage</a></li><li data-type='method' style='display: none;'><a href="Instance.html#uploadIotFirmware">uploadIotFirmware</a></li><li data-type='method' style='display: none;'><a href="Instance.html#uploadKernel">uploadKernel</a></li><li data-type='method' style='display: none;'><a href="Instance.html#uploadPartition">uploadPartition</a></li><li data-type='method' style='display: none;'><a href="Instance.html#uploadRamDisk">uploadRamDisk</a></li><li data-type='method' style='display: none;'><a href="Instance.html#waitForLineOnConsole">waitForLineOnConsole</a></li><li data-type='method' style='display: none;'><a href="Instance.html#waitForState">waitForState</a></li><li data-type='method' style='display: none;'><a href="Instance.html#waitForTaskState">waitForTaskState</a></li><li data-type='method' style='display: none;'><a href="Instance.html#waitForUserTask">waitForUserTask</a></li><li data-type='method' style='display: none;'><a href="Instance.html#webplayer">webplayer</a></li></ul></li><li><a href="Netdump.html">Netdump</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Netdump.html#clearLog">clearLog</a></li><li data-type='method' style='display: none;'><a href="Netdump.html#disconnect">disconnect</a></li><li data-type='method' style='display: none;'><a href="Netdump.html#handleMessage">handleMessage</a></li><li data-type='method' style='display: none;'><a href="Netdump.html#isEnabled">isEnabled</a></li><li data-type='method' style='display: none;'><a href="Netdump.html#start">start</a></li><li data-type='method' style='display: none;'><a href="Netdump.html#stop">stop</a></li></ul></li><li><a href="NetworkMonitor.html">NetworkMonitor</a><ul class='methods'><li data-type='method' style='display: none;'><a href="NetworkMonitor.html#clearLog">clearLog</a></li><li data-type='method' style='display: none;'><a href="NetworkMonitor.html#disconnect">disconnect</a></li><li data-type='method' style='display: none;'><a href="NetworkMonitor.html#handleMessage">handleMessage</a></li><li data-type='method' style='display: none;'><a href="NetworkMonitor.html#isEnabled">isEnabled</a></li><li data-type='method' style='display: none;'><a href="NetworkMonitor.html#start">start</a></li><li data-type='method' style='display: none;'><a href="NetworkMonitor.html#stop">stop</a></li></ul></li><li><a href="Project.html">Project</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Project.html#addKey">addKey</a></li><li data-type='method' style='display: none;'><a href="Project.html#createInstance">createInstance</a></li><li data-type='method' style='display: none;'><a href="Project.html#createRole">createRole</a></li><li data-type='method' style='display: none;'><a href="Project.html#deleteImage">deleteImage</a></li><li data-type='method' style='display: none;'><a href="Project.html#deleteIotFirmware">deleteIotFirmware</a></li><li data-type='method' style='display: none;'><a href="Project.html#deleteKernel">deleteKernel</a></li><li data-type='method' style='display: none;'><a href="Project.html#deleteKey">deleteKey</a></li><li data-type='method' style='display: none;'><a href="Project.html#destroy">destroy</a></li><li data-type='method' style='display: none;'><a href="Project.html#getInstance">getInstance</a></li><li data-type='method' style='display: none;'><a href="Project.html#getToken">getToken</a></li><li data-type='method' style='display: none;'><a href="Project.html#instances">instances</a></li><li data-type='method' style='display: none;'><a href="Project.html#keys">keys</a></li><li data-type='method' style='display: none;'><a href="Project.html#refresh">refresh</a></li><li data-type='method' style='display: none;'><a href="Project.html#roles">roles</a></li><li data-type='method' style='display: none;'><a href="Project.html#setQuotas">setQuotas</a></li><li data-type='method' style='display: none;'><a href="Project.html#uploadImage">uploadImage</a></li><li data-type='method' style='display: none;'><a href="Project.html#uploadIotFirmware">uploadIotFirmware</a></li><li data-type='method' style='display: none;'><a href="Project.html#uploadKernel">uploadKernel</a></li><li data-type='method' style='display: none;'><a href="Project.html#uploadVmfile">uploadVmfile</a></li><li data-type='method' style='display: none;'><a href="Project.html#vpnConfig">vpnConfig</a></li></ul></li><li><a href="Role.html">Role</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Role.html#destroy">destroy</a></li></ul></li><li><a href="Snapshot.html">Snapshot</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Snapshot.html#delete">delete</a></li><li data-type='method' style='display: none;'><a href="Snapshot.html#rename">rename</a></li><li data-type='method' style='display: none;'><a href="Snapshot.html#restore">restore</a></li></ul></li><li><a href="Team.html">Team</a></li><li><a href="User.html">User</a><ul class='methods'><li data-type='method' style='display: none;'><a href="User.html#destroy">destroy</a></li></ul></li><li><a href="WebPlayer.html">WebPlayer</a><ul class='methods'><li data-type='method' style='display: none;'><a href="WebPlayer.html#destroy">destroy</a></li><li data-type='method' style='display: none;'><a href="WebPlayer.html#refreshSession">refreshSession</a></li><li data-type='method' style='display: none;'><a href="WebPlayer.html#.sessions">sessions</a></li></ul></li></ul><h3>Events</h3><ul><li><a href="Instance.html#event:change">change</a></li><li><a href="Instance.html#event:panic">panic</a></li></ul><h3>Global</h3><ul><li><a href="global.html#AppListEntry">AppListEntry</a></li><li><a href="global.html#CommandResult">CommandResult</a></li><li><a href="global.html#FirmwareImage">FirmwareImage</a></li><li><a href="global.html#FridaPsResult">FridaPsResult</a></li><li><a href="global.html#I">I</a></li><li><a href="global.html#Image">Image</a></li><li><a href="global.html#KernelImage">KernelImage</a></li><li><a href="global.html#NetmonEntry">NetmonEntry</a></li><li><a href="global.html#PanicInfo">PanicInfo</a></li><li><a href="global.html#PartitionImage">PartitionImage</a></li><li><a href="global.html#PeripheralData">PeripheralData</a></li><li><a href="global.html#ProjectKey">ProjectKey</a></li><li><a href="global.html#ProjectQuotas">ProjectQuotas</a></li><li><a href="global.html#ProvisioningProfileInfo">ProvisioningProfileInfo</a></li><li><a href="global.html#RateInfo">RateInfo</a></li><li><a href="global.html#Response">Response</a></li><li><a href="global.html#ShellExecResult">ShellExecResult</a></li><li><a href="global.html#StartOptions">StartOptions</a></li><li><a href="global.html#StatEntry">StatEntry</a></li><li><a href="global.html#SupportedDevice">SupportedDevice</a></li><li><a href="global.html#ThreadInfo">ThreadInfo</a></li><li><a href="global.html#Token">Token</a></li><li><a href="global.html#UpgradeOptions">UpgradeOptions</a></li><li><a href="global.html#WebPlayerFeatureSet">WebPlayerFeatureSet</a></li><li><a href="global.html#WebPlayerSession">WebPlayerSession</a></li><li><a href="global.html#vmmio">vmmio</a></li></ul>
    
</nav>

<div id="main">
    
    <h1 class="page-title">agent.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict'

const WebSocket = require('ws')
const stream = require('stream')

const { sleep } = require('./util/sleep')

/**
 * @typedef {object} CommandResult
 * @property {integer} id - ID
 * @property {boolean} success - command result
 */

/**
 * @typedef {object} ShellExecResult
 * @property {integer} id - ID
 * @property {integer} exit-status
 * @property {string} output - command output
 * @property {boolean} success - command result
 */

/**
 * @typedef {object} FridaPsResult
 * @property {integer} id - ID
 * @property {integer} exit-status -
 * @property {string} output - frida-ps output
 * @property {boolean} success - command result
 */

/**
 * @typedef {object} AppListEntry
 * @property {string} applicationType
 * @property {string} bundleID
 * @property {integer} date
 * @property {integer} diskUsage
 * @property {boolean} isLaunchable
 * @property {string} name
 * @property {boolean} running
 */

/**
 * @typedef {object} StatEntry
 * @property {integer} atime
 * @property {integer} ctime
 * @property {object[]} entries
 * @property {integer} entries[].atime
 * @property {integer} entries[].stime
 * @property {integer} entries[].gid
 * @property {integer} entries[].mode
 * @property {integer} entries[].mtime
 * @property {string} entries[].name
 * @property {integer} entries[].size
 * @property {integer} entries[].uid
 * @property {integer} gid
 * @property {integer} mode
 * @property {integer} mtime
 * @property {string} name
 * @property {integer} size
 * @property {integer} uid
 */

/**
 * @typedef {object} ProvisioningProfileInfo
 * @property {string} name
 * @property {string} uuid
 * @property {string} teamId
 * @property {string[]} certs
 */

/**
 * A connection to the agent running on an instance.
 *
 * Instances of this class
 * are returned from {@link Instance#agent} and {@link Instance#newAgent}. They
 * should not be created using the constructor.
 * @hideconstructor
 */
class Agent {
  constructor (instance) {
    this.instance = instance
    this.connected = false
    this.uploading = false
    this.connectPromise = null
    this.id = 0
    this._keepAliveTimeout = null
    this._startKeepAliveTimeout = null
    this._lastPong = null
    this._lastPing = null
  }

  /**
   * Ensure the agent is connected.
   * @private
   */
  async connect () {
    this.pendingConnect = true
    if (!this.connected) {
      return await this.reconnect()
    }
  }

  /**
   * Ensure the agent is disconnected, then connect the agent.
   * @private
   */
  async reconnect () {
    if (this.connected) this.disconnect()

    if (this.connectPromise) return this.connectPromise

    this.connectPromise = await (async () => {
      while (this.pendingConnect) {
        try {
          await this._connect()
          break
        } catch (err) {
          if (err.stack.includes('Instance likely does not exist')) {
            throw err
          }
          if (err.stack.includes('unexpected server response (502)')) {
            // 'Error: unexpected server response (502)' means the device is not likely up yet
            await sleep(10 * 1000)
          }
          if (err.stack.includes('closed before the connection')) {
            // Do nothing this is normal when trying to settle a connection for a vm coming up
          } else {
            await sleep(7.5 * 1000)
          }
        }
      }

      this.connectPromise = null
    })()

    return this.connectPromise
  }

  async _connect () {
    this.pending = new Map()

    const endpoint = await this.instance.agentEndpoint()
    if (!endpoint) {
      this.pendingConnect = false
      throw new Error('Instance likely does not exist')
    }

    // Detect if a disconnection happened before we were able to get the agent endpoint.
    if (!this.pendingConnect) throw new Error('connection cancelled')

    const ws = new WebSocket(
      /^https/.test(endpoint)
        ? endpoint.replace(/^https/, 'wss')
        : /^http/.test(endpoint)
          ? endpoint.replace(/^http/, 'ws')
          : endpoint
    )

    this.ws = ws

    ws.on('message', data => {
      try {
        let message
        let id
        if (typeof data === 'string') {
          message = JSON.parse(data)
          id = message.id
        } else if (data.length >= 8) {
          id = data.readUInt32LE(0)
          message = data.slice(8)
        }

        const handler = this.pending.get(id)
        if (handler) {
          // will work regardless of whether handler returns a promise
          Promise.resolve(handler(null, message)).then(shouldDelete => {
            if (shouldDelete) this.pending.delete(id)
          })
        }
      } catch (err) {
        console.error('error in agent message handler', err)
      }
    })

    ws.on('close', (code, _reason) => {
      this.pending.forEach(handler => {
        handler(new Error(`disconnected with code ${code}`))
      })
      this.pending = new Map()
      this._disconnect()
    })

    return await new Promise((resolve, reject) => {
      ws.once('open', () => {
        if (this.ws !== ws) {
          try {
            ws.close()
          } catch (e) {
            // Swallow ws.close() errors.
          }

          reject(new Error('connection cancelled'))
          return
        }

        ws.on('error', err => {
          this.pending.forEach(handler => {
            handler(err)
          })
          this.pending = new Map()

          if (this.ws === ws) {
            this._disconnect()
          } else {
            try {
              ws.close()
            } catch (e) {
              // Swallow ws.close() errors.
            }
          }

          console.error('error in agent socket', err)
        })

        resolve()
      })

      ws.once('error', err => {
        if (this.ws === ws) {
          this._disconnect()
        } else {
          try {
            ws.close()
          } catch (e) {
            // Swallow ws.close() errors.
          }
        }

        reject(err)
      })
    })
      .then(() => {
        this.pendingConnect = false
        this.connected = true
        clearTimeout(this._startKeepAliveTimeout)
        this._startKeepAlive()
      })
      .catch(async err => {
        await this.instance.update()
        throw err
      })
  }

  _startKeepAlive () {
    if (!this.connected) return

    const ws = this.ws

    ws.ping()

    this._keepAliveTimeout = setTimeout(() => {
      if (this.ws !== ws) {
        try {
          ws.close()
        } catch (e) {
          // Swallow ws.close() errors.
        }
        return
      }

      const err = new Error('Agent did not get a response to ping in 10 seconds, disconnecting.')
      console.error('Agent did not get a response to ping in 10 seconds, disconnecting.')

      this.pending.forEach(handler => {
        handler(err)
      })
      this.pending = new Map()

      this._disconnect()
    }, 10 * 1000)

    ws.once('pong', async () => {
      if (ws !== this.ws) {
        return
      }

      clearTimeout(this._keepAliveTimeout)
      this._keepAliveTimeout = null

      if (!this.uploading) {
        this._startKeepAliveTimeout = setTimeout(this._startKeepAlive, 10 * 1000)
      }
    })
  }

  _stopKeepAlive () {
    if (this._startKeepAliveTimeout) {
      clearTimeout(this._startKeepAliveTimeout)
      this._startKeepAliveTimeout = null
    }
    if (this._keepAliveTimeout) {
      clearTimeout(this._keepAliveTimeout)
      this._keepAliveTimeout = null
    }
  }

  /**
   * Disconnect an agent connection. This is usually only required if a new
   * agent connection has been created and is no longer needed, for example
   * if the `crashListener` in the example at {@link Agent#crashes} is not
   * needed anymore.
   * @example
   * agent.disconnect();
   */
  disconnect () {
    this.pendingConnect = false
    this._disconnect()
  }

  _disconnect () {
    this.connected = false
    this._stopKeepAlive()
    if (this.ws) {
      try {
        this.ws.close()
      } catch (e) {
        // Swallow ws.close() errors.
      }
      this.ws = null
    }
  }

  /**
   * Send a command to the agent.
   *
   * When the command is responded to with an error, the error is thrown.
   * When the command is responded to with success, the handler callback is
   * called with the response as an argument.
   *
   * If the callback returns a value, that value will be returned from
   * `command`; otherwise nothing will happen until the next response to the
   * command. If the callback throws an exception, that exception will be
   * thrown from `command`.
   *
   * If no callback is specified, it is equivalent to specifying the callback
   * `(response) => response`.
   *
   * @param {string} type - passed in the `type` field of the agent command
   * @param {string} op - passed in the `op` field of the agent command
   * @param {Object} params - any other parameters to include in the command
   * @param {function} [handler=(response) => response] - the handler callback
   * @param {function} [uploadHandler] - a kludge for file uploads to work
   * @private
   */
  async command (type, op, params, handler, uploadHandler) {
    if (handler === undefined) handler = response => response

    const id = this.id
    this.id++
    const message = Object.assign({ type, op, id }, params)

    while (!this.ws) {
      await this.connect()
    }
    this.ws.send(JSON.stringify(message))
    if (uploadHandler) uploadHandler(id)

    return await new Promise((resolve, reject) => {
      this.pending.set(id, async (err, response) => {
        if (err) {
          reject(err)
          return
        }

        if (response.error) {
          reject(Object.assign(new Error(), response.error))
          return
        }

        try {
          const result = await handler(response)
          if (result !== undefined) {
            resolve(result)
            return true // stop calling us
          }
          return false
        } catch (e) {
          reject(e)
          return true
        }
      })
    })
  }

  sendBinaryData (id, data) {
    const idBuffer = Buffer.alloc(8, 0)
    idBuffer.writeUInt32LE(id, 0)
    if (data) this.ws.send(Buffer.concat([idBuffer, data]))
    else this.ws.send(idBuffer)
  }

  /**
   * Wait for the instance to be ready to use. On iOS, this will wait until Springboard has launched.
   * @example
   * let agent = await instance.agent();
   * await agent.ready();
   */
  async ready () {
    await this.command('app', 'ready')
  }

  /**
   * Uninstalls the app with the given bundle ID.
   * @param {string} bundleID - The bundle ID of the app to uninstall.
   * @param {Agent~progressCallback} progress - The progress callback.
   * @example
   * await agent.uninstall('com.corellium.demoapp', (progress, status) => {
   *     console.log(progress, status);
   * });
   */
  async uninstall (bundleID, progress) {
    await this.command('app', 'uninstall', { bundleID }, message => {
      if (message.success) return message
      if (progress &amp;&amp; message.progress) progress(message.progress, message.status)
    })
  }

  /**
   * Launches the app with the given bundle ID.
   * @param {string} bundleID - The bundle ID of the app to launch.
   * @example
   * await agent.run("com.corellium.demoapp");
   */
  async run (bundleID) {
    await this.command('app', 'run', { bundleID })
  }

  /**
   * Executes a given command
   * @param {string} cmd - The cmd to execute
   * @return {Promise&lt;ShellExecResult>}
   * @example
   * await agent.shellExec("uname");
   */
  async shellExec (cmd) {
    return await this.command('app', 'shellExec', { cmd })
  }

  /**
   * Launches the app with the given bundle ID.
   * @param {string} bundleID - The bundle ID of the app to launch, for android this is the package name.
   * @param {string} activity fully qualified activity to launch from bundleID
   * @example
   * await agent.runActivity('com.corellium.test.app', 'com.corellium.test.app/com.corellium.test.app.CrashActivity');
   */
  async runActivity (bundleID, activity) {
    await this.command('app', 'run', { bundleID, activity })
  }

  /**
   * Kill the app with the given bundle ID, if it is running.
   * @param {string} bundleID - The bundle ID of the app to kill.
   * @example
   * await agent.kill("com.corellium.demoapp");
   */
  async kill (bundleID) {
    await this.command('app', 'kill', { bundleID })
  }

  /**
   * Returns an array of installed apps.
   * @return {Promise&lt;AppListEntry[]>}
   * @example
   * let appList = await agent.appList();
   * for (app of appList) {
   *     console.log('Found installed app ' + app['bundleID']);
   * }
   */
  async appList () {
    const { apps } = await this.command('app', 'list')
    return apps
  }

  /**
   * Gets information about the file at the specified path. Fields are atime, mtime, ctime (in seconds after the epoch), size, mode (see mode_t in man 2 stat), uid, gid. If the path specified is a directory, an entries field will be present with
   * the same structure (and an additional name field) for each immediate child of the directory.
   * @return {Promise&lt;StatEntry>}
   * @example
   * let scripts = await agent.stat('/data/corellium/frida/scripts/');
   */
  async stat (path) {
    const response = await this.command('file', 'stat', { path })
    return response.stat
  }

  /**
   * A callback for file upload progress messages. Can be passed to {@link Agent#upload} and {@link Agent#installFile}
   * @callback Agent~uploadProgressCallback
   * @param {number} bytes - The number of bytes that has been uploaded.
   */

  /**
   * A callback for progress messages. Can be passed to {@link Agent#install}, {@link Agent#installFile}, {@link Agent#uninstall}.
   * @callback Agent~progressCallback
   * @param {number} progress - The progress, as a number between 0 and 1.
   * @param {string} status - The current status.
   */

  /**
   * Installs an app. The app's IPA must be available on the VM's filesystem. A progress callback may be provided.
   *
   * @see {@link Agent#upload} to upload a file to the VM's filesystem
   * @see {@link Agent#installFile} to handle both the upload and install
   *
   * @param {string} path - The path of the IPA on the VM's filesystem.
   * @param {Agent~progressCallback} [progress] - An optional callback that
   * will be called with information on the progress of the installation.
   * @async
   *
   * @example
   * await agent.install('/var/tmp/temp.ipa', (progress, status) => {
   *     console.log(progress, status);
   * });
   */
  async install (path, progress) {
    await this.command('app', 'install', { path }, message => {
      if (message.success) return message
      if (progress &amp;&amp; message.progress) progress(message.progress, message.status)
    })
  }

  /**
   * Returns an array of Mobile Configuration profile IDs
   * @return {Promise&lt;string[]>}
   * @example
   * let profiles = await agent.profileList();
   * for (p of profiles) {
   *     console.log('Found configuration profile: ' + p);
   * }
   */
  async profileList () {
    const { profiles } = await this.command('profile', 'list')
    return profiles
  }

  /**
   * Installs Mobile Configuration profile
   * @param {Buffer} profile - profile binary
   * @example
   * var profile = fs.readFileSync(path.join(__dirname, "myprofile.mobileconfig"));
   * await agent.installProfile(profile);
   */
  async installProfile (profile) {
    await this.command('profile', 'install', {
      profile: Buffer.from(profile).toString('base64')
    })
  }

  /**
   * Deletes Mobile Configuration profile
   * @param {string} profileID - profile ID
   * @example
   * await agent.removeProfile('com.test.myprofile');
   */
  async removeProfile (profileID) {
    await this.command('profile', 'remove', { profileID })
  }

  /**
   * Gets Mobile Configuration profile binary
   * @param {string} profileID - profile ID
   * @return {Promise&lt;Buffer>}
   * @example
   * var profile = await agent.getProfile('com.test.myprofile');
   */
  async getProfile (profileID) {
    const { profile } = await this.command('profile', 'get', { profileID })
    if (!profile) return null
    // eslint-disable-next-line new-cap
    return new Buffer.from(profile, 'base64')
  }

  /**
   * Returns an array of Provisioning profile descriptions
   * @return {Promise&lt;ProvisioningProfileInfo[]>}
   * @example
   * let profiles = await agent.listProvisioningProfiles();
   * for (p of profiles) {
   *     console.log(p['uuid']);
   * }
   */
  async listProvisioningProfiles () {
    const { profiles } = await this.command('provisioning', 'list')
    return profiles
  }

  /**
   * Installs Provisioning profile
   * @param {Buffer} profile - profile binary
   * @param {Boolean} trust - immediately trust installed profile
   * @example
   * var profile = fs.readFileSync(path.join(__dirname, "embedded.mobileprovision"));
   * await agent.installProvisioningProfile(profile, true);
   */
  async installProvisioningProfile (profile, trust = false) {
    await this.command('provisioning', 'install', {
      profile: Buffer.from(profile).toString('base64'),
      trust: trust
    })
  }

  /**
   * Deletes Provisioning profile
   * @param {string} profileID - profile ID
   * @example
   * await agent.removeProvisioningProfile('aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa');
   */
  async removeProvisioningProfile (profileID) {
    await this.command('provisioning', 'remove', {
      uuid: profileID
    })
  }

  /**
   * Approves (makes trusted) profile which will be installed later in a future for example during app installation via Xcode.
   * @param {string} certID - profile ID
   * @param {string} profileID - profile ID
   * @example
   * await agent.preApproveProvisioningProfile('Apple Development: my@email.com (NKJDZ3DZJB)', 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa');
   */
  async preApproveProvisioningProfile (certID, profileID) {
    await this.command('provisioning', 'preapprove', {
      cert: certID,
      uuid: profileID
    })
  }

  /**
   * Returns a temporary random filename on the VMs filesystem that by the
   * time of invocation of this method is guaranteed to be unique.
   * @return {Promise&lt;string>}
   * @see example at {@link Agent#upload}
   */
  async tempFile () {
    const { path } = await this.command('file', 'temp')
    return path
  }

  /**
   * Reads from the specified stream and uploads the data to a file on the VM.
   * @param {string} path - The file path to upload the data to.
   * @param {ReadableStream} stream - The stream to read the file data from.
   * @param {Agent~uploadProgressCallback} progress - The callback for install progress information.
   * @example
   * const tmpName = await agent.tempFile();
   * await agent.upload(tmpName, fs.createReadStream('test.ipa'));
   */
  async upload (path, stream, progress) {
    // Temporarily stop the keepalive as the upload appears to backlog
    // the control packets (ping/pong) at the proxy which can cause issues
    // and a disconnect
    this._stopKeepAlive()
    this.uploading = true
    await this.command(
      'file',
      'upload',
      { path },
      message => {
        // This is hit after the upload is completed and the agent
        // on the other end sends the reply packet of success/fail
        // Restart the keepalive as the upload buffer should be cleared
        clearTimeout(this._startKeepAliveTimeout)
        this._startKeepAlive()
        this.uploading = false

        // Pass back the message to the command() function to prevent
        // blocking or returning an invalid value
        return message
      },
      id => {
        let total = 0

        stream.on('data', data => {
          this.sendBinaryData(id, data)
          total += data.length
          if (progress) progress(total)
        })
        stream.on('end', () => {
          this.sendBinaryData(id)
        })
      }
    )
  }

  /**
   * Downloads the file at the given path from the VM's filesystem. Returns a node ReadableStream.
   * @param {string} path - The path of the file to download.
   * @return {Promise&lt;Readable>}
   * @example
   * const dl = agent.download('/var/tmp/test.log');
   * dl.pipe(fs.createWriteStream('test.log'));
   */
  download (path) {
    let command
    const agent = this
    return new stream.Readable({
      read () {
        if (command) return
        command = agent.command('file', 'download', { path }, message => {
          if (!Buffer.isBuffer(message)) return
          if (message.length === 0) return true
          this.push(message)
        })
        command.then(() => this.push(null)).catch(err => this.emit('error', err))
      }
    })
  }

  /**
   * Reads a packaged app from the provided stream, uploads the app to the VM
   * using {@link Agent#upload}, and installs it using {@link Agent#install}.
   * @param {ReadableStream} stream - The app to install, the stream will be closed after it is uploaded.
   * @param {Agent~progressCallback} installProgress - The callback for install progress information.
   * @param {Agent~uploadProgressCallback} uploadProgress - The callback for file upload progress information.
   * @example
   * await agent.installFile(fs.createReadStream('test.ipa'), (installProgress, installStatus) => {
   *     console.log(installProgress, installStatus);
   * });
   */
  async installFile (stream, installProgress, uploadProgress) {
    const path = await this.tempFile()

    await this.upload(path, stream, uploadProgress)
    stream.on('close', () => {
      stream.destroy()
    })

    await this.install(path, installProgress)

    try {
      await this.stat(path)
      await this.deleteFile(path)
    } catch (err) {
      if (!err.message.includes('Stat of file')) {
        throw err
      }
    }
  }

  /**
   * Delete the file at the specified path on the VM's filesystem.
   * @param {string} path - The path of the file on the VM's filesystem to delete.
   * @example
   * await agent.deleteFile('/var/tmp/test.log');
   */
  async deleteFile (path) {
    const response = await this.command('file', 'delete', { path })
    return response.path
  }

  /**
   * Change file attributes of the file at the specified path on the VM's filesystem.
   * @param {string} path - The path of the file on the VM's filesystem to delete.
   * @param {Object} attributes - An object whose members and values are the file attributes to change and what to change them to respectively. File attributes path, mode, uid and gid are supported.
   * @return {Promise&lt;CommandResult>}
   * @example
   * await agent.changeFileAttributes(filePath, {mode: 511});
   */
  async changeFileAttributes (path, attributes) {
    const response = await this.command('file', 'modify', { path, attributes })
    return response
  }

  /**
   * Subscribe to crash events for the app with the given bundle ID. The callback will be called as soon as the agent finds a new crash log.
   *
   * The callback takes two parameters:
   *  - `err`, which is undefined unless an error occurred setting up or waiting for crash logs
   *  - `crash`, which contains the full crash report data
   *
   * **Note:** Since this method blocks the communication channel of the
   * agent to wait for crash reports, a new {@link Agent} connection should
   * be created with {@link Instance#newAgent}.
   *
   * @see Agent#disconnect
   *
   * @example
   * const crashListener = await instance.newAgent();
   * crashListener.crashes("com.corellium.demoapp", (err, crashReport) => {
   *     if (err) {
   *         console.error(err);
   *         return;
   *     }
   *     console.log(crashReport);
   * });
   */
  async crashes (bundleID, callback) {
    await this.command('crash', 'subscribe', { bundleID }, async message => {
      const path = message.file
      const crashReport = await new Promise(resolve => {
        const stream = this.download(path)
        const buffers = []
        stream.on('data', data => {
          buffers.push(data)
        })
        stream.on('end', () => {
          resolve(Buffer.concat(buffers))
        })
      })

      await this.deleteFile(path)
      callback(null, crashReport.toString('utf8'))
    })
  }

  /** Locks the device software-wise.
   * @example
   * await agent.lockDevice();
   */
  async lockDevice () {
    await this.command('system', 'lock')
  }

  /** Unlocks the device software-wise.
   * @example
   * awaitagent.unlockDevice();
   */
  async unlockDevice () {
    await this.command('system', 'unlock')
  }

  /** Enables UI Automation.
   * @example
   * await agent.enableUIAutomation();
   */
  async enableUIAutomation () {
    await this.command('system', 'enableUIAutomation')
  }

  /** Disables UI Automation.
   * @example
   * await agent.disableUIAutomation();
   */
  async disableUIAutomation () {
    await this.command('system', 'disableUIAutomation')
  }

  /** Checks if SSL pinning is enabled. By default SSL pinning is disabled.
   * @returns {boolean}
   * @example
   * let enabled = await agent.isSSLPinningEnabled();
   * if (enabled) {
   *     console.log("enabled");
   * } else {
   *     console.log("disabled");
   * }
   */
  async isSSLPinningEnabled () {
    return (await this.command('system', 'isSSLPinningEnabled')).enabled
  }

  /** Enables SSL pinning.
   * @example
   * await agent.enableSSLPinning();
   */
  async enableSSLPinning () {
    await this.command('system', 'enableSSLPinning')
  }

  /** Disables SSL pinning.
   * @example
   * await agent.disableSSLPinning();
   */
  async disableSSLPinning () {
    await this.command('system', 'disableSSLPinning')
  }

  /** Shuts down the device.
   * @example
   * await agent.shutdown();
   */
  async shutdown () {
    await this.command('system', 'shutdown')
  }

  async acquireDisableAutolockAssertion () {
    await this.command('system', 'acquireDisableAutolockAssertion')
  }

  async releaseDisableAutolockAssertion () {
    await this.command('system', 'releaseDisableAutolockAssertion')
  }

  /** Connect device to WiFi.
   * @example
   * await agent.connectToWifi();
   */
  async connectToWifi () {
    await this.command('wifi', 'connect')
  }

  /** Disconnect device from WiFi.
   * @example
   * await agent.disconnectFromWifi();
   */
  async disconnectFromWifi () {
    await this.command('wifi', 'disconnect')
  }

  /** Get device property. */
  async getProp (property) {
    return await this.command('system', 'getprop', { property })
  }

  /**
   * Run frida on the device.
   * Please note that both arguments (pid and name) need to be provided as they are required by the Web UI.
   * @param {integer} pid
   * @param {string} name
   * @return {Promise&lt;CommandResult>}
   * @example
   * await agent.runFrida(449, 'keystore');
   */
  async runFrida (pid, name) {
    return await this.command('frida', 'run-frida', {
      target_pid: pid.toString(),
      target_name: name.toString()
    })
  }

  /**
   * Run frida-ps on the device and return the command's output.
   * @return {Promise&lt;FridaPsResult>}
   * @example
   * let procList = await agent.runFridaPs();
   * let lines = procList.output.trim().split('\n');
   * lines.shift();
   * lines.shift();
   * for (const line of lines) {
   *     const [pid, name] = line.trim().split(/\s+/);
   *     console.log(pid, name);
   * }
   */
  async runFridaPs () {
    return await this.command('frida', 'run-frida-ps')
  }

  /**
   * Run frida-kill on the device.
   * @return {Promise&lt;CommandResult>}
   * @example
   * await agent.runFridaKill();
   */
  async runFridaKill () {
    return await this.command('frida', 'run-frida-kill')
  }
}

module.exports = Agent
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.2</a> on Mon Aug 07 2023 14:58:54 GMT+0000 (Coordinated Universal Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>


<script src="scripts/collapse.js" defer></script>


</body>
</html>
